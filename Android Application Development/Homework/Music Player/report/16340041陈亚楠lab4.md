# 中山大学数据科学与计算机学院本科生实验报告
## （2018年秋季学期）
| 课程名称 | 手机平台应用开发 | 任课老师 | 郑贵锋 |
| :------------: | :-------------: | :------------: | :-------------: |
| 年级 | 2016级 | 专业（方向） | 数字媒体 |
| 学号 | 16340041 | 姓名 | 陈亚楠 |
| 电话 | 18709548602 | Email | chenyn97@outlook.com |
| 开始日期 | 2018.11.29 | 完成日期 |2018.12.6|

---

## 一、实验题目

**简单音乐播放器**

---

## 二、实现内容

1. 播放、暂停、停止、退出功能，按停止键会重置封面转角，进度条和播放按钮；按退出键将停止播放并退出程序；
2. 后台播放功能，按手机的返回键和home键都不会停止播放，而是转入后台进行播放；
3. 进度条显示播放进度、拖动进度条改变进度功能；
4. 播放时图片旋转，显示当前播放时间功能；
5. 在保持上述原有的功能的情况下，使用rxJava代替Handler进行UI的更新；
6. 选歌：用户可以点击选歌按钮自己选择歌曲进行播放，换歌后不仅能正常实现上述的全部功能，选歌成功后不自动播放，重置播放按钮，重置进度条，重置歌曲封面转动角度。

---

## 三、课堂实验结果
### (1)实验截图

- 打开程序主页面：

  <img src="https://gitee.com/chenyn227/PersonalProject4/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1544192610.png" width=400px>

- 开始播放：

  <img src="https://gitee.com/chenyn227/PersonalProject4/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1544192541.png" width=400px>

- 暂停：

  <img src="https://gitee.com/chenyn227/PersonalProject4/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1544192561.png" width=400px>

- 停止：

  <img src="https://gitee.com/chenyn227/PersonalProject4/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1544192572.png" width=400px>

- 选歌：

  <img src="https://gitee.com/chenyn227/PersonalProject4/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1544192591.png" width=400px>

### (2)实验步骤以及关键代码

#### 1. 布局文件：

这次的布局文件与之前相比新增加了开源控件`CircleImageView`与`SeekBar`的使用，它们的用法如下：

`CircleImageView`：

```xml
<de.hdodenhof.circleimageview.CircleImageView                                   		xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/album_image"
    android:layout_width="match_parent"
    android:layout_height="0dp"
    android:layout_weight="1"
    android:src="@drawable/img"
    app:civ_border_width="0dp"
    app:civ_border_color="@android:color/white"
    android:layout_marginVertical="8dp"/>
```

`SeekBar`：

```xml
<SeekBar
    style="@style/Base.Widget.AppCompat.ProgressBar.Horizontal"
    android:id="@+id/seekbar"
    android:layout_width="0dp"
    android:layout_height="match_parent"
    android:layout_weight="1" />
```

#### 2. 使用Service

`Service`(服务)是一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如`Activity`），服务一旦被启动将在后台一直运行，即使启动服务的组件（`Activity`）已销毁也不受影响。

`Service`在后台运行，它不能与用户直接进行交互。在默认情况下，`Service`运行在应用程序进程的主线程之中。

##### 注册Service：

在`AndroidManifest.xml`中注册`Service`：

```xml
<service
            android:name=".MusicService"
            android:enabled="true"
            android:exported="true"></service>
```

##### 实现Service:

在本次项目中，我们要重写`public IBinder onBind(Intent intent)`方法和`public void onDestroy()`方法。

由于`Service`没有界面，所以我们控制`Service`需要通过一个`Activity`来接收用户输入。通过绑定`Activity`与 `Service` ， 可 以 实 现 `Activity `与`Service`之间的交互。`Service`的`onBind()`方法所返回一个`IBinder`对象，它可以被当成该`Service`组件所返回的代理对象，`Service`允许客户端通过该`IBinder`对象来访问`Service`内部的数据，实现客户端与`Service`之间的通信。

```java
public IBinder onBind(Intent intent) {
    //        // TODO: Return the communication channel to the service.
    //        throw new UnsupportedOperationException("Not yet implemented");
    try {
        mediaPlayer.setDataSource(Environment.getExternalStorageDirectory() + "/data/山高水长.mp3");
        Log.i("Init Music Sourse: ", Environment.getExternalStorageDirectory().toString());
        mediaPlayer.prepare();
        mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
            @Override
            public void onCompletion(MediaPlayer mp) {
                ifComplete = true;
            }
        });
    } catch (IOException e) {
        Log.e("Media prepare failed, ", "Error: " + e.toString());
        Log.i("Init music path: ", Environment.getExternalStorageDirectory().toString());
    }
    return binder;
}
```

`IBinder`是远程对象的基本接口，是为高效率进行进程间通讯设计的轻量级远程过程调用机制的核心，它描述了与远程对象交互的抽象协议。`IBinder`只提供一个消息传递接口，只能通过`int`类型的输入参数`code`对消息进行识别和判断。

在本项目中，我们通过创建一个继承于` Binder`的类`MyBinder`来保持`Activity`和`Service`的通信，通过`transact`和`ontransact`的方法来进行通信，`transact`使我们可以向远端的`IBinder`对象发送发出调用,
`ontransact`方法使我们的远程对象能够响应接收到的调用，`transact()`直到对方的`Binder.onTransact()`方法调用完成后才返回：

```java
public class MyBinder extends Binder {
    @Override
    protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException {
        switch (code) {
            case PLAY_CODE:
                playOrPause();
                break;
            case STOP_CODE:
                stopMusic();
                break;
            case SEEKBAR_CODE:
                mediaPlayer.seekTo(data.readInt());
                break;
            case CURRRENT_TIME_CODE:
                reply.writeInt(mediaPlayer.getCurrentPosition());
                break;
            case TOTAL_TIME_CODE:
                reply.writeInt(mediaPlayer.getDuration());
                break;
            case NEW_MUSIC_CODE:
                newMusic(Uri.parse(data.readString()));
                reply.writeInt(mediaPlayer.getDuration());
                break;
            default:
                break;
        }
        return super.onTransact(code, data, reply, flags);
    }
}
```

通过`transact()`发送的数据是`Parcel`，`Parcel`是一种一般的缓冲区，除了有数据外还带有一些描述它内容的元数据。元数据用于管理`IBinder`对象的引用，这样就能在缓冲区从一个进程移动到另一个进程时保存这些引用。这样就保证了当一个`IBinder`被写入到`Parcel`并发送到另一个进程中，如果另一个进程把同一`IBinder`的引用回发到原来的进程，那么这个原来的进程就能接收到发出的那个`IBinder`的引用。这种机制使`IBinder`和`Binder`像唯一标志符那样在进程间管理。

我们通过以下方式与服务通信并获取信息：

```java
Parcel data = Parcel.obtain();
Parcel reply = Parcel.obtain();
try {
    mBinder.transact(TOTAL_TIME_CODE, data, reply, 0);
} catch (Exception e) {
    Log.e("Service Connection Failed", e.toString());
}
```

##### 绑定Activity和Service：

在本项目中，我们在`Activity`中调用`bindService`保持与`Service`的通信，这种模式适用于`Service`和访问者之间需要进行方法调用或数据交换的情况。?`Activity`启动时绑定`Service`：

```java
Intent intent = new Intent(this, MusicService.class);
bindService(intent, sc, BIND_AUTO_CREATE);
```

`bindService`成功后回调`onServiceConnected`函数，通过`IBinder`获取`Service`对象，实现`Activity`与`Service`的绑定： 

```java
private ServiceConnection sc = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mBinder = service;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        try {
            mBinder.transact(TOTAL_TIME_CODE, data, reply, 0);
        } catch (Exception e) {
            Log.e("Service Connection Failed", e.toString());
        }
        totalTime = reply.readInt();
        seekBar.setProgress(0);
        seekBar.setMax(totalTime);
        //毫秒转时间
        endTime.setText(time.format(new Date(totalTime)));
        startTime.setText(time.format(new Date(0)));
    }

    @Override
    public void onServiceDisconnected(ComponentName name) { }
};
```

##### 停止Service：

当停止服务时，必须解除绑定：

```java
mHandler.removeCallbacks(mRunnable);
unbindService(sc);
try {
	MainActivity.this.finish();
	System.exit(0);
} catch (Exception e) {
	e.printStackTrace();
}
```

#### 3.访问文件资源管理器选歌

##### 申请权限：

在`Android6.0`及之后，`Android`对用户权限的管理更加严格与安全，因此我们在读取资源管理器的时候除了静态申请之外，还需要进行动态申请，动态申请的方式如下：

```java
//读写权限
private static String[] STORAGE_PERMISSIONS = {
    Manifest.permission.READ_EXTERNAL_STORAGE,
    Manifest.permission.WRITE_EXTERNAL_STORAGE };
@Override
protected void onCreate(Bundle savedInstanceState) {
    //获取权限
    ActivityCompat.requestPermissions(this, STORAGE_PERMISSIONS, FILE_PERMISSION_REQUEST_CODE);
}
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    if (requestCode == FILE_PERMISSION_REQUEST_CODE) {
        Intent intent = new Intent(this, MusicService.class);
        bindService(intent, sc, BIND_AUTO_CREATE);
    }
}
```

##### 选择歌曲播放：

筛选音频文件类型：

```java
fileChooseBtn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("audio/*");
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        startActivityForResult(intent,FILE_PERMISSION_REQUEST_CODE);
    }
});
```

##### 解析音乐信息：

通过`MediaMetadataRetriever`来解析MP3文件信息，`MediaMetadataRetriever`类可以解析出媒体文件的基本信息，例如音频和视频文件。

```java
MediaMetadataRetriever mmr = new MediaMetadataRetriever();
mmr.setDataSource(MainActivity.this,data.getData());
songName.setText(mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE));
singerName.setText(mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST));
byte[] picture = mmr.getEmbeddedPicture();
if(picture.length!=0){
    Bitmap bitmap = BitmapFactory.decodeByteArray(picture, 0, picture.length);
    albumImage.setImageBitmap(bitmap);
}
mmr.release();
```

##### 重写选择文件后的返回函数：

```java
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (data != null) {
        try{
            //与服务通信更新UI
            //...
            //解析音乐信息
            //...
			//选歌后停止自动播放
            isPlay = false;
            playOrPauseBtn.performClick();
        }catch (Exception e){
            Log.e("Choose new Music", "Error: " + e.toString() );
        }
    }
    super.onActivityResult(requestCode, resultCode, data);
}
```

#### 4. 使用Handler： 

由于`Android`操作系统的线程安全机制，不能在非`UI`线程中重绘`UI`，所以在我们在用户线程中更改进度条，更换封面图片等操作会造成程序强制关闭，因此我们可以使用`Handler`和`RxJava`解决上述问题，下面先简要介绍`Handler`的使用。

这里我们需要单独用一个线程来观察`MediaPlayer`的进度变化，然后使用`Handler`通知UI变化。

`Android`操作系统在`UI`线程中，缺省维护该`MessageQueue`和一个`Looper`。`Looper`通过一个死循环，当有消息`Message`加入队列时， 通过`FIFO`的顺序处理消息。一个`Message`中包括了处理`Message`的`Handler`对象还有消息内容。`Handler`与`UI`线程是同一个线程，所以我们在用户线程中完成计算之后，可以通过向消息队列加入一个消息，通知特定的`Handler`去更改`UI`。

##### 创建与实现Handler：

与UI同一线程的消息处理器`Handler`，专门负责处理非`UI `线程发送过来的各种消息，更新`UI`。

```java
@SuppressLint("HandlerLeak")
private final Handler handler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what) { // 根据消息类型进行操作
            case -1:
                handler.removeCallbacks(myThread);
                seekBar.setProgress(0);
                startTime.setText(time.format(0));
                albumImage.setRotation(0);
                break;
            default:
                if(msg.arg1 >= totalTime)
                    stopBtn.performClick();
                seekBar.setProgress(msg.arg1);
                startTime.setText(time.format(new Date(msg.arg1)));
                albumImage.setPivotX(albumImage.getWidth() / 2 );
                albumImage.setPivotY(albumImage.getHeight() / 2);//支点在图片中心
                albumImage.setRotation(msg.arg1 / 30);
                handler.postDelayed(myThread, 1);
        }
    }
};*/
```

##### 创建新线程：

该线程负责判断`MediaPlayer`的状态，将不同类型的消息发送给上面定义的`Handler`：

```java
public Runnable  myThread = new Runnable() {
    @Override
    public void run() {
        Message msg = handler.obtainMessage();
        if(isStop){
            msg.what = -1;
            handler.sendMessage(msg);
            return;
        }
        try{
            //与服务通信
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            mBinder.transact(CURRRENT_TIME_CODE, data, reply, 0);
            msg.arg1 = reply.readInt();
        }catch (Exception e){
            Log.d("Run", "run: " + e.toString());
            return;
        }
        handler.sendMessage(msg);
    }
};
```

#### 5. 使用RxJava

RxJava是一个基于事件订阅的异步执行的一个类库，具有异步、基于观察者设计模式、Subscribe (订阅)的特点，它的异步实现，通过一种扩展的观察者模式来实现，采用注册(Register)或者称为订阅(Subscribe)的方
式观察被观察者；

##### 添加依赖：

```java
implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'
implementation 'io.reactivex.rxjava2:rxjava:2.2.4'
```

##### 添加被观察者：

与传统观察者模式不同， RxJava 的事件回调方法除了普通事件`onNext() `之外，还定义了两个特殊的事件：`onCompleted() `和 `onError()`。`onCompleted()`表示事件队列完结；`RxJava`规定，当不会再有新的`onNext() `发出时，需要触发 `onCompleted() `方法作为标志。`onError()`表示事件队列异常，在事件处理过程中出异常时，`onError()`会被触发，同时事件队列自动终止，不允许再有事件发出。在一个正确运行的事件序列中, `onCompleted() `和 `onError() `有且只有一个，并且是事件序列中的最后一个。需要注意的是，`onCompleted() `和 `onError() `二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。

在`rxjava2`中，不是简单添加一个`Observable`，而是需要寄放在`CompositeDisposable`里面：

```java
// 在Observable对象中查询歌曲的播放时间，用onNext方法传递给Observer。
// Observer对象观察到Observable发送的播放时间后，完成UI的更新。
private CompositeDisposable mCompositeDisposable = new CompositeDisposable();
private Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {
    @Override
    public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
        while (true) {
            //与服务通信
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            try {
                //获取信息
                mBinder.transact(CURRRENT_TIME_CODE, data, reply, 0);
                //每隔一毫秒查询一次歌曲的状态
                Thread.sleep(1);
            } catch (Exception e){
                Log.e("SERVICE CONNECTION", "onServiceConnected: " + e.toString());
            }
            //读取当前进度
            observableEmitter.onNext(reply.readInt());
            //reply.readInt() == 1 读取 isFinish判断歌曲是否被动停止
            // isStop 判断歌曲是否主动停止
            if(reply.readInt() == 1 || isStop)
                break;
        }
        observableEmitter.onComplete();
    }
});
```

##### 添加观察者：

在`rxjava2`中，不是叫`Observer`了，而是加了个`Disposable`，表示可处理，当播放/暂停按钮被点击时，我们需要给我们的`DisposableObserver`做订阅：

```java
//订阅观察者
DisposableObserver<Integer> disposableObserver = new DisposableObserver<Integer>() {
    @Override
    //设置UI
    public void onNext(Integer integer) {
        Log.d("onNext", "" + integer);
        seekBar.setProgress(integer);
        startTime.setText(time.format(new Date(integer)));
        albumImage.setPivotX(albumImage.getWidth()/2);
        albumImage.setPivotY(albumImage.getHeight()/2);//支点在图片中心
        albumImage.setRotation(integer/30);
    }
    //模拟点击停止按键
    @Override
    public void onComplete() {
        stopBtn.performClick();
    }

    @Override
    public void onError(Throwable e) {
        Log.d("onError", "" + e.toString());
    }
};
//在新线程监听
observable.subscribeOn(Schedulers.newThread())
        //在主线程更新
        .observeOn(AndroidSchedulers.mainThread())
        //绑定
        .subscribe(disposableObserver);
//管理DisposableObserver的容器
mCompositeDisposable.add(disposableObserver);
```

这里需要注意的是`RxJava`默认情况下是单线程的，在不指定线程的情况下， `RxJava`遵循的是线程不变的
原则，在哪个线程调用`subscribe()`，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。

如果需要切换线程，就需要用到`Scheduler`，调度器相当于线程控制器，`RxJava`通过它来指定每一段代码应该运行在什么样的线程。`RxJava`已经内置了几个 `Scheduler`，这里我们用到的有：

- `Schedulers.newThread()`: 总是启用新线程，并在新线程执行操作；
- `AndroidSchedulers.mainThread()`，它指定的操作将在`Android`主线程运行；

对于任何`Observable`我们可以定义在两个不同的线程，使用`Observable.observeOn()`可以定义在一个线程上，可以用来监听和检查从`Observable`最新发出的`items`（`Subscriber` 的 `onNext`，`onCompleted`和 `onError`方法会执行在 `observeOn `所指定的线程上），`Observable.subscribeOn() `来定义一个线程，将其运行我们 `Observable `的代码。这里，我们在在新线程监听，在主线程更新。

### (3)实验遇到的困难以及解决思路

**1.** `java.lang.IllegalStateException: No activity`报错：

在点击退出按钮是，我在点击事件处理函数里处理调用`finish()`方法，还手动调用了`onDestory`方法，结果就出现了上面的问题，经过查阅得知，在`finish()`方法之后，系统会自动调用`onDestory`销毁当前`Activity`，所以相当于是多次调用销毁函数，第二次`Activity`自然是不存在了，删除`onDestory`方法问题解决；

**2.** 重新选择歌曲或重新播放出现`FATAL EXCEPTION: io.reactivex.exceptions.ProtocolViolationException: It is not allowed to subscribe with a(n) com.androidhw.chenyn.musicplayer.MainActivity$1 multiple times. Please create a fresh instance of com.androidhw.chenyn.musicplayer.MainActivity$1 and subscribe that to the target source instead. `报错：

由于观察者订阅被观察者只能订阅一次，在歌曲播放完毕或者点击停止按钮调用`onComplete()`方法后，一对观察者和被观察者的生命也就终止了，因此我们需要在每次需要监听的时候动态创建一个局部变量`disposableObserver`，使得其在被订阅的时候成为一个新的变量。

**3.** 播放或暂停时拖动进度条不产生效果，进度条重新归零：

这是因为在`seekBar`的点击事件中，与服务进行通信时，没有将当前进度写进`data`导致的，加入代码`data.writeInt(progress)`问题解决。

---

## 四、实验思考及感想

通过这次实验，学习了在`Android`中使用`MediaPlayer`，以及`Android`中的另一个组件`Service`，学习使用`Service`与`Activity`进行通信，并进行了简单的多线程编程，以及使用`Handler`、`RxJava`两种方式进行`UI`的更新。

`MediaPlayer`由于有之前学习`UWP`课程的基础，对于`MediaPlayer`的理解与使用难度较小；而在进行`Service`的学习的时候，这是一个相较以前比较新的概念，可以理解，但是在自己实际写代码的时候其实也是遇到了很多问题的，尤其加上使用`Handler`、`RxJava`两种方式进行`UI`的更新的时候，有的时候会处于思维比较混乱的状态，对于函数间作用的理解还是不够到位；除此之外，深切感受到了设计模式在编程中的重要与广泛，`Handler`对应于命令模式，`RxJava`则与观察者模式相似，通过这次实验编程，也加深了对于这两种设计模式的理解。

---
