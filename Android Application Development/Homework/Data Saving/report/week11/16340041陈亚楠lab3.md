# 中山大学数据科学与计算机学院本科生实验报告
## （2018年秋季学期）
| 课程名称 | 手机平台应用开发 | 任课老师 | 郑贵锋 |
| :------------: | :-------------: | :------------: | :-------------: |
| 年级 | 2016 | 专业（方向） | 数字媒体 |
| 学号 | 16340041 | 姓名 | 陈亚楠 |
| 电话 | 18709548602 | Email | chenyn97@outlook.com |
| 开始日期 | 2018.11.15 | 完成日期 |2018.11.22|

---

## 一、实验题目

个人项目3——数据存储应用开发 数据存储（二）

---

## 二、实现内容

本次实验实现了实验的**基本要求**以及**加分项**。

要求细节详见`README.md`。

---

## 三、课堂实验结果
### (1)实验截图

- 点击Login切换到登录界面：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090898.png" width=400px>

- 若Username为空，则发出Toast提示：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091040.png" width=400px>

- 若Password为空，则发出Toast提示：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091049.png" width=400px>

- 若Username不存在，则发出Toast提示 ：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091082.png" width=400px>

- 若密码不正确，则发出Toast提示：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091065.png" width=400px>


- 点击Register切换到注册页面：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090902.png" width=400px>

- 若Username为空，则发出Toast提示：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090925.png" width=400px>

- 若New Password为空，则发出Toast提示：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090937.png" width=400px>

- 若New Password与Confirm Password不匹配，则发出Toast提示 ：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090972.png" width=400px>

- 注册成功：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090979.png" width=400px>

- 若Username已经存在，则发出Toast提示：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090998.png" width=400px>

- 评论页面：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091101.png" width=400px>

- 若EditText为空，则发出Toast提示 ：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091108.png" width=400px>

- 发送评论：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091129.png" width=400px>

- 短按评论：弹出对话框，显示该评论的用户以及通讯录中该用户的电话号码（存在）：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091400.png" width=400px>

- 短按评论：弹出对话框，显示该评论的用户以及通讯录中该用户的电话号码（不存在）：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091406.png" width=400px>

- 长按按评论：是当前用户，弹出是否删除的对话框：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091441.png" width=400px>

- 长按按评论：非当前用户，弹出是否举报的对话框：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091420.png" width=400px>

- 进入手机图库进行图片选择：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543090910.png" width=400px>

- ImageView显示本次选择的图片 ：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091230.png" width=400px>

- 在评论页面，每条Item应当正确显示用户的头像：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/Screenshot_1543091324.png" width=400px>

- 项目结构：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/structure.png">

- User表：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/user.png">

- Comment表：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/comment.png">

- agreeRelation表：

  <img src="https://gitee.com/chenyn227/PersonalProject3/raw/master/report/Thursday/16340041ChenYanan/week11/img/agree.png">


### (2)实验步骤以及关键代码

#### 1.完成布局文件书写：

本次项目的布局文件总共有三个，包括：

- `activity_comment .xml`：评论页面布局文件；
- `activity_main .xml`：注册/登录页面布局文件：
- `item.xml`：`ListVIew` `item`布局文件；

布局文件的实现没有什么难度，我们只需要注意将评论页面`ListView`和评论输入 `EditText` 在各自的线性布局内将`layout_weight `属性设置为1即可：

```xml
<LinearLayout>
    <ListView
        android:id="@+id/comments"
        android:layout_weight="1"></ListView>
        <LinearLayout>
            <EditText
                android:id="@+id/commentInput"
                android:layout_weight="1"/>
    </LinearLayout>
</LinearLayout>
```

另外，在注册页面我将设置头像的View设置为ImageButton，在添加图像后图像周围会出现灰色边框，这里只需要将`ImageButton`的`background`属性设置为`#00000000`即可：

```xml
<ImageButton
    android:id="@+id/headshot"
    android:src="@drawable/add"
    android:visibility="gone"
    android:scaleType="centerCrop"
    android:background="#00000000"/>
```

#### 2.用户、评论基本属性.java文件的完成：

本次实验中的`User.java`、`Comment.java`两个文件编辑了用户与评论两个实体的基本属性与基本方法（`set`、`get`方法），下面列出两个实体的基本属性设置：

```java
//User.java
private String username;
private String password;
private String headshotUri;
public User(String username, String password, String headshotUri) {
    this.username = username;
    this.password = password;
    this.headshotUri = headshotUri;
}
//Comment.java
private String commentId;
private String creator;
private String commentTime;
private String commentContent;
public Comment(String creator, String commentTime, String commentContent) {
    this.commentId = UUID.randomUUID().toString();
    this.creator = creator;
    this.commentTime = commentTime;
    this.commentContent = commentContent;
}
```

这里对`commentId`的生成方法进行说明，这里我使用了`自定义全局唯一ID (GUID) `来对`commentId`进行唯一标识，它的实现方式如下：

```java
this.commentId = UUID.randomUUID().toString();
```

#### 3.数据库的设计：

本次实验中关于数据库及其操作的所有代码均包含在`DataBase.java`文件中，本次实验只有一个数据库，但该数据库包括三个表：

- `User Table`：存储用户信息的表，包含`username` 、`password`、 `headshot`三个字段，其中`username`为主码；
- `Comment Table`：存储评论的表，包含`commentId`、`creator`、`commentTime`、`commentContent`四个字段，其中`commentId`为主码；
- `agreeRelation Table`：存储用户与评论之间点赞关系的表，包含`commentId`、`username`两个字段，无主码，若用户点赞了某条评论，则将该用户的`username`与评论的`commentId`加入该表，若取消点赞则删除该关系。

##### 创建数据库：

本项目中创建的数据库名字为`lab3DataBase`，它的主要信息与创建方法如下：

```java
public class DataBase extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = "lab3DataBase";
    private static final int DATABASE_VERSION = 1;
    private static final String USER_TABLE = "Users";
    private static final String COMMENTS_TABLE = "Comments";
    private static final String AGREE_RELATION_TABLE = "agreeRelation";

    public DataBase(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        //...
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { }
```

通过以下代码在`Activity`的`onCreate`方法中打开数据库：

```java
myDataBase = new DataBase(getApplicationContext());
```

通过以下代码在`Activity`的`onDestroy`方法中关闭数据库：

```java
@Override
protected void onDestroy() {
    myDataBase.close();
    super.onDestroy();
}
```

##### 创建表：

在`DateBase.java`文件`public void onCreate(SQLiteDatabase db)`方法中创建数据库中的表，创建方法如下：

```java
String CREATE_USERS_TABLE = "CREATE TABLE if not exists " + USER_TABLE
        + "(username TEXT PRIMARY KEY, "
        + "password TEXT, "
        + "headshot TEXT)";
db.execSQL(CREATE_USERS_TABLE);
```

##### 增、删、查

本次试验涉及到的关于数据库的操作包含了增、删、查三种操作，下面举例详解三中操作的实现方法：

- 增：

  ```java
  //添加用户
  public void addUser(User user) {
      SQLiteDatabase db = getWritableDatabase();
      ContentValues values = new ContentValues();
      values.put("username", user.getUsername());
      values.put("password", user.getPassword());
      values.put("headshot", user.getHeadshotUri());
      db.insert(USER_TABLE, null, values);
  }
  ```

- 删：

  ```java
  //删除评论
  public void removeComment(String commentId) {
      SQLiteDatabase db = this.getWritableDatabase();
      db.delete(COMMENTS_TABLE, "commentId = ?", new String[] {commentId});
  }
  ```

- 查：

  ```java
  //判断当前用户是否点赞过某条评论
  public Boolean ifAgreeRelationExist(String commentId, String username) {
      SQLiteDatabase db = getReadableDatabase();
      String selectQuery = "SELECT * FROM " + AGREE_RELATION_TABLE + " WHERE commentId = '"+commentId+"' and username = '"+username+"'";
      Cursor cursor = db.rawQuery(selectQuery, null);
      if (cursor != null && cursor.getCount() > 0) {
          cursor.moveToFirst();
          Log.e("TAG=ifAgreeRelationExist", username + " have agreed " + commentId);
          return true;
      } else {
          Log.e("TAG=ifAgreeRelationExist", username + " not agreed " + commentId);
          return false;
      }
  }
  ```

下面给出`DateBase.java`文件中各个方法的说明：

```java
//添加用户
public void addUser(User user) {}
//查询用户，判断当前用户是否存在
public Boolean ifUserExist(String username) {}
//根据用户名得到用户密码
public String getUserPassword(String username) {}
//根据用户名得到用户头像
public String getUserHeadshot(String username) {}
//添加评论
public void addComment(Comment comment) {}
//删除评论
public void removeComment(String commentId) {}
//得到所有评论，在ListView显示
public ArrayList<Comment> getAllComments() {}
//添加点赞关系
public void addAgreeRelation(String commentId, String username) {}
//取消点赞关系
public void deleteAgreeRelation(String commentId, String username) {}
//判断当前用户是否点赞过某条评论
public Boolean ifAgreeRelationExist(String commentId, String username) {}
//获取评论的被点赞数
public int getAgreeNumber(String commentId) {}
//评论页面加载头像
public Bitmap loadHeadshot(String path) {}
```

#### 4.完成ListViewAdapter

`ListView`自定义适配器的编写在之前我们已经学习过，这里不做赘述，这里仅就`getView`方法进行说明。

`ListViewAdapter`的构造情况如下，我们在其构造方法中除了传进进本的参数外，还传进了当前登录的用户的用户名以及实验的数据库：

```java
public ListViewAdapter(Context context, ArrayList<Comment> commentLists, String currentUser, DataBase dataBase) {
    this.context = context;
    this.commentList = commentLists;
    this.currentUser = currentUser;
    this.myDataBase = dataBase;
}
```

`ViewHolder`的设计代码如下：

```java
private class ViewHolder {
    public ImageView headshot;
    public TextView username;
    public TextView commentTime;
    public TextView commentContent;
    public ImageView agreeImage;
    public TextView agreeNumber;
}
```

在`getView`方法中，我们在填充用户头像这块数据时，进行了判断，若该评论的创建者使用了默认头像，则直接进行`setImageResource`设置，否则从数据库`User`表中读取头像的保存路径，根据路径加载头像：

```java
//填充数据
//头像
String headshotUri = myDataBase.getUserHeadshot(creator);
if (headshotUri.equals("defaultHeadshot")) {
    viewHolder.headshot.setImageResource(R.drawable.me);
} else {
   viewHolder.headshot.setImageBitmap(myDataBase.loadHeadshot(headshotUri));
}
```

在填充点赞的图片时，也进行了判断：

```java
//当前用户是否点赞了该评论
final Boolean ifAgreed = myDataBase.ifAgreeRelationExist(commentId, currentUser);
if (ifAgreed == true) {
    viewHolder.agreeImage.setImageResource(R.drawable.red);
} else {
    viewHolder.agreeImage.setImageResource(R.drawable.white);
}
```

除此之外，我们在`ListViewAdapter`中也实现了当点击点赞图片时，要完成的操作：

```java
//点赞图片被点击处理事件
viewHolder.agreeImage.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        ImageView agreeImage = v.findViewById(R.id.agreeImage);
        if (myDataBase.ifAgreeRelationExist(commentId, currentUser)) {
            myDataBase.deleteAgreeRelation(commentId, currentUser);
            agreeImage.setImageResource(R.drawable.white);
        } else {
            myDataBase.addAgreeRelation(commentId, currentUser);
            agreeImage.setImageResource(R.drawable.red);
        }
  viewHolder.agreeNumber.setText(Integer.toString(myDataBase.getAgreeNumber(commentId)));
    }
});
```

#### 5.读取联系人：

在`Android6.0`及之后，`Android`对用户权限的管理更加严格与安全，因此我们在读取联系人信息的时候除了静态申请之外，还需要进行动态申请，动态申请的方式如下：

```java
//检查读取联系人权限
protected Boolean checkForContactPermission() {
    return PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.READ_CONTACTS);
}
//申请权限
protected void requestContactPermission() {
    if (!checkForContactPermission()) {
        ActivityCompat.requestPermissions(this, new String[]{ Manifest.permission.READ_CONTACTS}, CONTACT_REQUEST_CODE);
        Log.e("TAG=requestContactPermission", "no permitted and requested");
    } else {
        Log.e("TAG=requestContactPermission", "have permitted");
    }
}
@Override
public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {
    if (requestCode == CONTACT_REQUEST_CODE) {
        Log.e("TAG=onRequestPermissionsResult", "request contact");
    }
}
```

查询联系人获得其电话号码的方式如下：

```java
String phoneNumber = "";
String displayInfo = "";
Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
        null,
        ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME + " = \"" + selectedComment.getcreator() + "\"",
        null, null, null);
if (cursor != null && cursor.getCount() > 0) {
    cursor.moveToFirst();
    phoneNumber = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
    displayInfo = "Phone: " + phoneNumber;
} else {
    displayInfo = "Phone number not exist.";
}
```

#### 6. 用户头像的保存与加载

在本次实验中，我并不是直接在数据库中保存图片，而是选择了将图片复制到`Internal Storage`中，并将图片的绝对路径保存到数据库中，并根据该路径进行评论页面的头像的加载显示。

在保存图片时，我们要打开图库，这一步通过`Intent`可以解决：

```java
//从图库中选择图片
protected void choosePhotoFromGallay() {
    Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
    startActivityForResult(intent, PICK_PHOTO_REQUEST);
}

//图库选择图片回调函数
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (resultCode == this.RESULT_CANCELED) {
        return;
    }
    if (requestCode == PICK_PHOTO_REQUEST) {
        if (resultCode == RESULT_OK) {
            Uri uri = data.getData();
            if(uri != null){
                try {
                    Bitmap bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), uri);
                    headshotUri = saveImage(bitmap);
                    headshot.setImageBitmap(bitmap);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

保存图片：

```java
//保存图片到内存，并返回图片路径
public String saveImage(Bitmap bitmap) {
    ContextWrapper cw = new ContextWrapper(getApplicationContext());
    //图片文件夹目录名字
    File imgDir = cw.getDir("savedImg", Context.MODE_PRIVATE);
    //图片命名
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    String imgName = "lab3Img" + timeStamp + ".jpg";
    File img = new File(imgDir, imgName);
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream(img);
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);
        fos.flush();
        fos.close();
        return img.getAbsolutePath();
    } catch (Exception e) {
        e.printStackTrace();
    }
    //返回标记，评论页面显示头像时进行判断
    return "defaultHeadshot";
}
```

加载图片：

```java
//评论页面加载头像
public Bitmap loadHeadshot(String path) {
    try {
        File file = new File(path);
        Bitmap bitmap = BitmapFactory.decodeStream(new FileInputStream(file));
        return bitmap;
    }
    catch (FileNotFoundException e)
    {
        e.printStackTrace();
    }
    return null;
}
```

#### 7.其他操作

##### 登录成功跳转页面传参设置

在登录成功后，我们要将登录用户的用户名作为参数传递到评论页面的`Activity`，作为当前用户：

```java
String usernameBundleArg = username.getText().toString();
Intent intent = new Intent(getApplicationContext(), CommentActivity.class);
intent.putExtra("currentUser", usernameBundleArg);
startActivity(intent);
```

##### 评论时间的格式化

```java
Calendar calendar = Calendar.getInstance();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String commentTime = df.format(calendar.getTime());
```

### (3)实验遇到的困难以及解决思路

**1.** `android.database.sqlite.SQLiteException: no such column`报错：

在进行数据库查询操作时，我刚开始的查询语句是这样的写的：

```java
String selectQuery = "SELECT * FROM " + AGREE_RELATION_TABLE + " WHERE commentId = “ + commentId;
```

结果就显示了上面的报错提示，经过上网查询得知，上面的查询方法适用于`commentId`为`int`数据类型，对于`String`类型，应使用下面的引用方法：

```java
String selectQuery = "SELECT * FROM " + AGREE_RELATION_TABLE + " WHERE commentId = '"+commentId+"'";
```

**2.** `Unable to start activity ComponentInfo: android.database.CursorIndexOutOfBoundsException: Index 0 requested, with a size of 0`报错：

在进行数据库查询操作时，经常会出现上面的这种错误，这是因为有的时候`cursor`可能不为`null`但是仍然可能为空，我们将`if (cursor != null)`替换为`if (cursor != null && cursor.getCount > 0)`可以解决问题。

**3.** 读取联系人时提示`permission is denied`，这个问题就是在`Android6.0`及之后，我们在读取联系人信息的时候需要进行动态申请的问题，解决方法及代码详见实验步骤。

**4.** `java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity`报错：

在进行`ListView`的`Item`点击事件时，我们需要弹出对话框：

```java
AlertDialog.Builder builder = new AlertDialog.Builder(getApplicationContext());
```

我采用了上面这种方法结果出现了这种报错信息，上网查询得知，在`ListView`等之类的填充`item`视图和创建对话框时，不能使用`getApplicationContext()`，而`new AlertDialog.Builder(this)` 这种方法可以自己读取 `alertDialogTheme` 属性，因此我修改代码如下问题得以解决：

```java
AlertDialog.Builder builder = new AlertDialog.Builder(CommentActivity.this);
```

**5.** `java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.TextView.setText(java.lang.CharSequence)' on a null object reference`报错：

这是因为在点赞图片被点击处理事件的代码中，进行点赞数量的显示时，我的代码如下：

```java
viewHolder.agreeImage.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        ImageView agreeImage = v.findViewById(R.id.agreeImage);
        TextView agreeNumber = v.findViewById(R.id.agreeNumber);
        //...
  agreeNumber.setText(Integer.toString(myDataBase.getAgreeNumber(commentId)));
    }
});
```

由于被监听的仅是被点赞的图片，这样写自然是找不到`agreeNumber`这个`TextView`控件了，修改代码如下：

```java
viewHolder.agreeImage.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        ImageView agreeImage = v.findViewById(R.id.agreeImage);
        //...
        viewHolder.agreeNumber.setText(Integer.toString(myDataBase.getAgreeNumber(commentId)));
    }
});
```

问题解决，这个问题纯属粗心大意惹的祸。

---

## 四、实验思考及感想

`Android`中数据存储总共有五种方式：`SharedPreferences`、内部存储、外部存储、`SQLite`数据库以及网络连接，通过两周的作业实践完成了前四种存储方式的学习，对于`Android`的数据存储也算是有了一个大概的了解；而本周的项目也算是实现了一个小型的应用程序，整个项目完成下来，对于之前学习的事件处理、`ListView`相关知识进行了复习，温故而知新，在debug的过程中对于他们也有了更深的理解。

---
