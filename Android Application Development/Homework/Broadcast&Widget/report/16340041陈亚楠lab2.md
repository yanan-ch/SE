# 中山大学数据科学与计算机学院本科生实验报告
## （2018年秋季学期）
| 课程名称 | 手机平台应用开发 | 任课老师 | 郑贵锋 |
| :------------: | :-------------: | :------------: | :-------------: |
| 年级 | 2016级 | 专业（方向） | 数字媒体 |
| 学号 | 16340041 | 姓名 | 陈亚楠 |
| 电话 | 18709548602 | Email | chenyn97@outlook.com |
| 开始日期 | 2018.10.18 | 完成日期 |2018.11.1|

---

## 一、实验题目

**中山大学智慧健康服务平台应用开发**

- Broadcast 使用
- AppWidget 使用

---

## 二、实现内容

### 1.Broadcast 使用

- 静态广播：启动应用，产生随机推荐食品的通知，点击通知正确跳转到所推荐食品的详情界面。
- 动态广播：点击收藏后产生提示食品已加入收藏列表的通知，点击通知跳转到收藏列表。
- Eventbus : 点击收藏列表图标正确添加食品到收藏列表，每点击一次，添加对应的一个食品到收藏列表并产生一条通知。

### 2.AppWidget 使用

实现静态广播、动态广播两种改变widget内容的方法：

- Widget 布局显示正常。
- 静态广播：启动应用Widget是否有随机推荐食品。
- 动态广播：点击收藏图标后，Widget是否提示食品已加入收藏列表。
- 点击widget是否正确跳到对应的界面。

---

## 三、课堂实验结果
### (1)实验截图

#### 1.Broadcast 使用

- 在启动应用时，会有通知产生，随机推荐一个食品：

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067634.png" width=400px>


- 点击通知跳转到所推荐食品的详情界面：

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067648.png" width=400px>


- 点击收藏图标，会有对应通知产生，并通过Eventbus在收藏列表更新数据：

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067655.png" width=400px>


- 点击通知返回收藏列表：

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067660.png" width=400px>


#### 2.AppWidget 使用

- widget初始情况如下： 

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067755.png" width=400px>


- 点击widget启动应用，并在widget随机推荐一个食品： 

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067776.png" width=400px>

- 点击widget跳转到所推荐食品的详情界面： 

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067782.png" width=400px>

- 点击收藏图标，widget相应更新：

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067793.png" width=400px>


- 点击widget跳转到收藏列表：

  <img src="https://gitee.com/chenyn227/PersonalProject2/raw/master/report/Thursday/16340041ChenYanan/img/Screenshot_1541067799.png" width=400px>


### (2)实验步骤以及关键代码

个人项目2实现的内容主要为使用静态广播与动态广播来改变Notification和Widget的内容，另外通过Eventbus进行收藏列表数据的更新。

#### 1.广播：

广播是一种广泛运用的在应用程序之间传输信息的机制。Android广播机制包含三个基本元素：广播（发送广播）、广播接收器（接受广播）、`Intent`（保存广播信息的媒介）。广播的过程大致为注册广播、发送广播、接收广播、注销广播。广播可以分为静态广播与动态广播。

##### 1.1静态广播

静态广播就是在`AndroidManifest.xml`中声明的广播，本项目中我们使用静态广播进行食品推荐Notification与Widget操作的处理。

- **注册广播**，在`AndroidMainfest.xml `中进行注册：

  ```xml
  <receiver android:name=".StaticReceiver">
  <intent-filter>
      <action android:name="com.chenyn.androidproject1.MyStaticFilter" />
  </intent-filter>
  ```

- **发送广播**，将要发送的FoodModel信息包含在`Intent`中，通过广播发送出去：

  ```java
  private void sendStaticBroadcast(int n) {
      //返回一个0到n-1的整数
      Random random = new Random();
      int position = random.nextInt(n);
      Bundle bundles = new Bundle();
      bundles.putSerializable("broad", foodList.get(position));
      //notification广播
      Intent intentBroadcast = new Intent("com.chenyn.androidproject1.MyStaticFilter"); //定义Intent
      intentBroadcast.setComponent(new ComponentName(getPackageName(),getPackageName()+".StaticReceiver"));
      intentBroadcast.putExtras(bundles);
      sendBroadcast(intentBroadcast);
      //widget广播
      Intent widgetIntentBroadcast = new Intent("android.appwidget.action.APPWIDGET_UPDATE");
      widgetIntentBroadcast.putExtras(bundles);
      sendBroadcast(widgetIntentBroadcast);
  }
  ```

- **新建静态广播接收器类**`StaticReceiver.java`，重写`onReceive()`函数，当接收到广播时，进行事件处理；对于静态广播，在安装应用程序时，系统包管理器会注册接收器：

  ```java
  public class StaticReceiver extends BroadcastReceiver {
      @Override
      public void onReceive(Context context, Intent intent) {
          //Notification
      }         
  }
  ```

由于静态广播是常驻型的，在应用程序关闭后，如果由信息广播来，程序依然会被系统调用自动运行，因此我们不需要手动设置注销广播。

##### 1.2动态广播

动态广播是在应用运行时注册广播接收器，它的生命周期比静态广播短，但优先级要高于静态广播。

- **注册广播**：

  ```java
  //Notification
  IntentFilter dynamicFilter = new IntentFilter();
  dynamicFilter.addAction("com.chenyn.androidproject1.MyDynamicFilter");  
  dynamicReceiver = new DynamicReceiver();
  registerReceiver(dynamicReceiver, dynamicFilter);    
  //Widget
  IntentFilter widget_dynamic_filter = new IntentFilter();
  widget_dynamic_filter.addAction("com.chenyn.androidproject1.MyWidgetDynamicFilter");
  DynamicReceiver widgetDynamicReceiver = new DynamicReceiver(); 
  registerReceiver(widgetDynamicReceiver, widget_dynamic_filter); 
  ```

- **发送广播**，注意这里要在 Android 主界面中将 launchMode 设置为 singleInstance，使得点击Notification 后不会另外新建一个收藏列表：

  ```java
  Bundle bundle = new Bundle();
  bundle.putSerializable("dynamicBroad", selectedItem);
  //Notification
  Intent intentBroadcast = new Intent();   
  intentBroadcast.setAction("com.chenyn.androidproject1.MyDynamicFilter");
  intentBroadcast.putExtras(bundle);
  sendBroadcast(intentBroadcast);
  //Widget
  Intent widgetBroadcast = new Intent();   
  widgetBroadcast.setAction("com.chenyn.androidproject1.MyWidgetDynamicFilter");
  widgetBroadcast.putExtras(bundle);
  sendBroadcast(widgetBroadcast);
  ```

- **新建动态广播接收器类**`DynamicReceiver.java`，重写`onReceive()`函数，当接收到广播时，进行事件处理，这里我们要完成`Notification`和`Widget`两个组件的事件处理：

  ```java
  public class DynamicReceiver extends BroadcastReceiver {
      private final String DYNAMICACTION = "com.chenyn.androidproject1.MyDynamicFilter";
      private final String WIDGETDYNAMICACTION = "com.chenyn.androidproject1.MyWidgetDynamicFilter";
      @Override
      public void onReceive(Context context, Intent intent) {
          if (intent.getAction().equals(DYNAMICACTION)) {    //动作检测
              //Notification...
          }
          else if (intent.getAction().equals(WIDGETDYNAMICACTION)) {
              //Widget...
          }
      }
  }
  ```

- **注销广播**：

  ```java
  @Override
  protected void onDestroy() {
      super.onDestroy();
      unregisterReceiver(dynamicReceiver);
  }
  ```

另外，为了与注册对应起来，注销广播最好就是放在同一个`Activity`两个相对应的生命周期里面，以防止接收器从活动的上下文中泄露和多次注册。

#### 2.Notification

通知是可以在应用的常规 UI 外部向用户显示的消息。当我们告知系统发出通知时，它将先以图标的形式显示在通知区域中。用户可以打开抽屉式通知栏查看通知的详细信息。

我们在 `Notification.Builder` 对象中为通知指定 UI 信息和操作通过调用`Notification.Builder.build()`来创建通知，它返回一个我们具体规范了的`Notification` 对象。

```java
//获取状态通知栏管理
NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
//创建通知
Notification.Builder builder = new Notification.Builder(context, CHANNEL_ID);
```

在`Notification` 对象中，必须设置小图标、标题以及详细文本，他们分别由`setSmallIcon()` 、`setContentTitle()` 、`setContentText()` 设置。

在 `Notification` 内部，操作本身由 `PendingIntent` 定义，在本次的项目中，我们要在点击`Nitification`后，启动`MainActivity`，因此我们应该在`PendingIntent`包含启动 `MainActivity` 的 `Intent`，并在`builder`中传递该`Intent`，它由`setContentIntent()`设置：

```java
Bundle bundle = intent.getExtras();
FoodModel foodModel = (FoodModel)bundle.getSerializable("dynamicBroad");
Intent intent1 = new Intent(context, MainActivity.class);
Bundle bundle1 = new Bundle();
intent1.putExtras(bundle);
PendingIntent contentIntent = PendingIntent.getActivity(context, 0, intent1, PendingIntent.FLAG_UPDATE_CURRENT);
```

```java
builder.setContentTitle("已收藏")
        .setContentText(foodModel.getFoodName())
        .setSmallIcon(R.drawable.back)
        .setContentIntent(contentIntent)
        //设置这个标志当用户单击面板就可以让通知将自动取消
        .setAutoCancel(true);
```

另外需要说明的是，在Android 8.0之后，Google对通知做了修改优化，增加了通知渠道功能对通知进行了分类，APP中每一个通知都属于一个通知渠道。由于本次项目也是运行在SDK8.0上，所以也需要实现通知渠道功能。创建通知渠道需要三个参数channelId、channelName、importance ，以下为本次实验中的代码示例：

```java
String CHANNEL_ID = "Channel_02";
NotificationChannel mChannel = null;
if (mChannel == null) {
    String name = "channel_02";//渠道名字
    //HIGH或者MAX才能弹出通知到屏幕上
    int importance = NotificationManager.IMPORTANCE_HIGH;
    mChannel = new NotificationChannel(CHANNEL_ID, name, importance);
    manager.createNotificationChannel(mChannel);
}
```

最后，调用 `NotificationManager.notify()` 发出通知，将 `Notification` 对象传递给系统：

```java
Notification notify = builder.build();
manager.notify(0,notify);
```

#### 3.Widget

要创建一个App Widget，我们需要以下几个东西：`AppWidgetProviderInfo`、`AppWidgetProvider`、`View layout`，其中，`AppWidgetProviderInfo`描述了App Widget的元数据；`AppWidgetProvider`类定义了App Widget基于广播事件的与应用部件传递信息的基本方法，我们可以通过它，控制应用部件更新、启用、禁用和删除；`View layout`定义了App Widget的初始视图。以上三个文件我们可以在Android Studio中通过直接添加一个Widget组件得到。

首先，我们需要在`AndroidManifest.xml`文件中声明`AppWidgetProvider`类`NewAppWidget`：

```xml
<receiver android:name=".NewAppWidget" >
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
        <action android:name="com.chenyn.androidproject1.MyWidgetStaticFilter" />
    </intent-filter>
    <meta-data android:name="android.appwidget.provider"
               android:resource="@xml/new_app_widget_info" />
</receiver>
```

然后，编辑修改new_app_widget_info.xml文件，new_app_widget_info.xml其实就是 `AppWidgetProviderInfo`，它定义了App Widget诸如最小宽度、最小高度、初始的布局资源等的基本性质，关于这些性质的介绍请参见[链接](https://developer.android.com/guide/topics/appwidgets/)：

```xml
<?xml version="1.0" encoding="utf-8"?>
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialKeyguardLayout="@layout/new_app_widget"
    android:initialLayout="@layout/new_app_widget"
    android:minWidth="300dp"
    android:minHeight="50dp"
    android:previewImage="@drawable/full_star"
    android:resizeMode="horizontal|vertical"
    android:updatePeriodMillis="86400000"
    android:widgetCategory="home_screen|keyguard"></appwidget-provider>
```

最后，我们修改NewAppWidget.java文件，它对应的是`AppWidgetProvider`类，在这里我们需要重写`onUpdate()`函数与`onReceive()`函数。

`onUpdate()`函数在需要更新App Widget时被调用执行，这里需要使用到一种用户程序访问主屏幕和修改特定区域内容的方法：`RemoteView `架构 。 `RemoteView `架构允许用户程序更新主屏幕的View，点击Widget 激活点击事件， Android 会将其转发给用户程序，由`AppWidgetProviders`类处理，使得用户程序可更新主屏幕Widget：

```java
@Override
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    RemoteViews updateView = new RemoteViews(context.getPackageName(), R.layout.new_app_widget);//实例化RemoteView,其对应相应的Widget布局
    Intent i = new Intent(context, MainActivity.class);
    PendingIntent pi = PendingIntent.getActivity(context, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
    updateView.setOnClickPendingIntent(R.id.appwidget_star, pi); //设置点击事件
    ComponentName me = new ComponentName(context, NewAppWidget.class);
    appWidgetManager.updateAppWidget(me, updateView);
}
```

`onReceive()`函数是接收广播的回调函数，它定义了在接收到广播时需要执行的事件。本次项目中，我们需要在接收到广播后，传递被点击的食品的信息，并在App Widget中更新显示内容：

```java
@Override
public void onReceive(Context context, Intent intent ){
    super.onReceive(context, intent);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);    if(intent.getAction().equals("android.appwidget.action.APPWIDGET_UPDATE")){
        Bundle bundle = intent.getExtras();
        RemoteViews remoteViews=new RemoteViews(context.getPackageName(),R.layout.new_app_widget);
        if (bundle.getSerializable("broad") != null) {
            remoteViews.setTextViewText(R.id.appwidget_text, "今日推荐 " + ((FoodModel) bundle.getSerializable("broad")).getFoodName());
        }
        //...
        PendingIntent contentIntent = PendingIntent.getActivity(context, 0, intent1, PendingIntent.FLAG_UPDATE_CURRENT);
        remoteViews.setOnClickPendingIntent(R.id.appwidget_text, contentIntent);
        ComponentName myWidget = new ComponentName(context, NewAppWidget.class);
        appWidgetManager.updateAppWidget(myWidget, remoteViews);
    }
}
```

#### 4.EventbBus

`EventBus`是Android的发布/订阅事件总线，他简化了组件之间的通信，分离了事件发送者与接收者，在多个`Activities`，`Fragments`和后台进程间良好执行，防范了复杂易错的依赖和生命周期问题，也使得我们的编程更加简单。

通常来讲，`EventBus`使用分为三步：

首先，定义要发布与订阅的事件，在本项目中，我们将在Activity之间传送的FoodModel设置为一个事件：

```java
public class MessageEvent {
    private FoodModel foodModel;
    public MessageEvent(FoodModel foodModel) {
        this.foodModel = foodModel;
    }

    public FoodModel getFoodModel() {
        return this.foodModel;
    }

    public void setFoodModel(FoodModel foodModel) {
        this.foodModel = foodModel;
    }
}
```

其次，准备订阅者，这里我们的订阅者是`MainActivity`：

- 声明与注释我们的订阅方法，本项目中，事件接收者在接收到事件后，要返回收藏夹，这里我们要设置的是`MainActivity`中的`ListView`可见，`RecyclerView`不可见，并且图标也要做出相应修改：

  ```java
  @Subscribe(threadMode = ThreadMode.MAIN)
  public void onMessageEvent(FoodModel foodModel) {
      favorList.add(foodModel);
      foodListView.setVisibility(View.INVISIBLE);
      favorListView.setVisibility(View.VISIBLE);
      fab = findViewById(R.id.fabOnMain);
      fab.setImageResource(R.drawable.mainpage);
      listViewAdapter.notifyDataSetChanged();
  }
  ```

- 注册与注销订阅者，这两步在一个`Activity`的`onStart()`函数和`onStop()`函数中完成：

  ```java
  @Override
  protected void onStart() {
      super.onStart();
      EventBus.getDefault().register(this);
  }
  @Override
  protected void onDestroy() {
      super.onDestroy();
      EventBus.getDefault().unregister(this);
  }
  ```

最后，发送事件，本项目中，我们使用`EventBus`的目的是进行收藏夹数据的更新，所以事件的发布要在用户点击收藏夹按钮进行食品添加时进行，所以在`addToFavorList()`函数中发布事件：

```java
private void addFavorList() {
    final ImageView collectBtn = findViewById(R.id.collectIcon);
    collectBtn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v){
            EventBus.getDefault().post(selectedItem);
            //...
        }
    }
}
```

### (3)实验遇到的困难以及解决思路

- 1.Android Studio报错“`'Builder(android.content.Context)' is deprecated as of API 26: Android 8.0 (Oreo)`”，并且通知不显示：

  在使用Notification.Builder(this)方法时，这里的代码画了一条横线，Android Studio提示`'Builder(android.content.Context)' is deprecated`，这是因为我本次项目使用的是API26.0，Google在Android8.0中引用了**通知渠道**，Google官方已经丢弃了这种构造方法，取而代之的是使用带有参数`channelId`的`Builder`的构造函数：`NotificationCompat.Builder(Context context, String channelId)`，参见[Stackoverflow](https://stackoverflow.com/questions/45462666/notificationcompat-builder-deprecated-in-android-o)。

  于是在程序中定义一个String类型的channelId，并修改Builder如下：

  ```java
  Notification.Builder builder = new Notification.Builder(context, CHANNEL_ID);
  ```

  问题解决。

- 2.在详情页面点击“已收藏”Notification，不返回收藏夹列表：

  这个问题其实是`EventBus`的`post()`函数写错导致的，原来的错误写法：

  ```java
  EventBus.getDefault().post(new MessageEvent(selectedItem));
  ```

  改正之后：

    ```java
  EventBus.getDefault().post(selectedItem);
    ```

  这个时候`selectedItem`是一个已经确定了的我们要传送的`FoodModel`，在`post`的时候是不需要的`new`的。

- 3.对于Notification和Widget，我们在进行广播的处理的时候，是根据不同的action来采取不同的处理方式的，但我在实验中，由于复制`actionName`的时候出错，导致后来花费了好久的时间的重新修改（捂脸），不值得不值得。

---

## 四、实验思考及感想

这次项目需要掌握的主要就是`Broadcast`这个组件以及`Notification`和`Widget`两个部件，还有`EventBus`的使用。`Broadcast`与`EventBus`的中心思想其实就是订阅与发布，这种模式在编程中很常见，也很容易理解。相比于`Intent`与`Bundle`，`EventBus`真的简化了组件之间的通信，这种方式很受用。除此之外，也学习了静态广播与动态广播，感受到了它们的区别，静态广播的生命周期通常长于动态广播，它是一种常驻型广播，因此静态广播通常都是用来对系统时间进行监听；而动态广播不是常驻型广播 ，它会随着`context`的终止而终止。此外，动态广播的优先级是高于静态广播的。

---

